package Collections.f.big_o_notation;

/**
 * Описание сложности алгоритма(рассмотрим основные):
 * O(1) - алгоритм выполняется за постоянное премя(самый эффективный)
 * O(n) - при увелич элементов, время увелич линейно
 * O(log n) - при увелич элементов, время увелич логарифмически(бинарный поиск)
 */
public class BigONotation {
    //получение элемента из массива - это O(1)
    //потому что при "доставании" она обращается к ячейке памяти

    //добавление элементов в конец List тоже O(1)
    //но если добавляем, когда нету места в конце(пересоздание списка) - тогда время = O(n)
    //удаоение из конца списка - O(1)
    //лдаление не из конца - O(n)

    //O на LinkedList:

    //удаление - O(n)
    //добавление именно в начало элемента - O(1)
    //достать элемент - O(n)
}

