package Algorithms.c.sorting.c.insertion.sorting;

import java.util.Arrays;

/**
 *  Сортировка вставкой(работает за n2(n в квадрате))
 *  идея такая же - двигаемся например справа налево(справа отсортированная часть а слева не отсортированная)
 *  разница в том, что - в левую часть(уже отсортированную) мы не заходим и даже можем ее вернуть
 *  принцип в том что мы ищем месть элементу в уже отсортированной часть массива(ищем место как в пузырьке)(на не наоборот, сортируем то что еще не отсортировано)
 */
public class IterateInsertionSorting {
    public static void main(String[] args) {
        int[] arr = {-5, 23, 2, 55, 13, 634, 23, 12, 313};
        IterateInsertionSorting.insertSorting(arr);
        System.out.println("sort arr = " + Arrays.toString(arr));
    }

    //можно оптимизировать - если применить бинарный поиск(ищет по отсортированному массиву) вместо цикла while
    public static void insertSorting(int[] arr){
        for(int k = 1; k < arr.length; k++){
            //элемент, который мы будем внедрять в отсортированный список(отсортированный - это список перед индексом k)
            int newElement = arr[k];
            //индекс элемента с которым сравниваем в данный момент
            int location = k-1;
            //пока индекс элемента который хотим внедрить не дошел до конца массива и пока он больше чем элемент в данный
            // момент с которым сравниваем в отсортированном списке, то мы элементу где стоит наш мы его убираем и ставим элемент из отсортированного списка
            while(location >=0 && arr[location]>newElement){
                arr[location+1] = arr[location];
                location--;
            }
            //только здесь мы поставим уже наш элемент туда где он должен быть
            arr[location+1] = newElement;
        }
    }

    //оптимизированная сортировка вставкой(сделать)
    public static void optimizaeInsertSorting(int[] arr){

    }
}
